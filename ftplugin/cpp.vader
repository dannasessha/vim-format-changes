"  test file for /ftplugin/cpp.vim
"  may be needed to create a new test flow, as mine is currently
"  based off exer, and we'd like to be able to run without added config
"  can simply run :Vader here or :Vader <filename> maybe useful

Before:
  unlet! input expected
  unlet! g:vader_exception g:vader_throwpoint

Execute(source vimscript file):
  let sourcefile = 'cpp.vim'
  if !filereadable(sourcefile)
    echoerr 'Something went wrong. File does not exist: '. sourcefile
  endif
  execute 'source' sourcefile

Execute(tautology):
  let input = ""
  let expected = ""
  AssertEqual expected, input

" calling IngestGitAnnotate() from Vader runs the command line 
" invocation from its own custom
" working directory. However, the stdout return to this call 
" is still written as a string into a list.
Execute(IngestGitAnnotate returns a list):
  let input = type(IngestGitAnnotate())
  let expected = v:t_list
  AssertEqual expected, input

Execute(if IngestGitAnnotate returns a list with contents, each item is a string.):
  let input =  IngestGitAnnotate() 
  let expected = v:t_string
  for entry in input
  AssertEqual expected, type(entry)
  endfor

Execute(CollectUncommittedLines returns a list):
  let input = CollectUncommittedLines([])
  let expected = []
  AssertEqual expected, input

Execute(CollectUncommittedLines throws an error with a string argument type):
  AssertThrows CollectUncommittedLines("string")

Execute(CollectUncommittedLines throws an error with a number argument type):
  AssertThrows CollectUncommittedLines(1)

Execute(CollectUncommittedLines throws an error with a float argument type):
  AssertThrows CollectUncommittedLines(2.424241)

Execute(CollectUncommittedLines throws an error with a dict argument type):
  let diction = #{a: 'aa', b: 'bb'}
  AssertThrows CollectUncommittedLines(diction)

  "TODO funcref

Execute(CollectUncommittedLines throws an error with a boolean argument type):
  AssertThrows CollectUncommittedLines(v:true)

Execute(CollectUncommittedLines throws an error with a false boolean argument type):
  AssertThrows CollectUncommittedLines(v:false)

Execute(CollectUncommittedLines throws an error with a null argument type):
  AssertThrows CollectUncommittedLines(v:null)

Execute(CollectUncommittedLines throws an error with a numbers in list):
  AssertThrows CollectUncommittedLines([1,2])

Execute(CollectUncommittedLines throws an error with floats in list):
  AssertThrows CollectUncommittedLines([1.86523, 2.7523])

Execute(CollectUncommittedLines throws an error with two strings in list):
  AssertThrows CollectUncommittedLines(["StringX", "StringY"])

Execute(CollectUncommittedLines ...or an equal with two strings in list):
  let input = CollectUncommittedLines(["StringX", "StringY"])
  let expected = []
  AssertEqual expected, input 

Execute(CollectUncommittedLines: One matching string in lines [would be returned from IngestGitAnnotate]):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 1 1 1', 'string2'])
  let expected = ['0000000000000000000000000000000000000000 1 1 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: No matching strings in lines, hash short by one digit):
  let input = CollectUncommittedLines(['000000000000000000000000000000000000000 1 1 1', 'string2'])
  let expected = [] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: No matching strings in lines, hash long by one digit):
  let input = CollectUncommittedLines(['00000000000000000000000000000000000000000 1 1 1', 'string2'])
  let expected = [] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: No matching strings in lines, hash off by one digit substitution):
  let input = CollectUncommittedLines(['0000000000100000000000000000000000000000 1 1 1', 'string2'])
  let expected = [] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: One matching string in lines with realistic values):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 1 1 1', '19d605f410c83235ae7E757445e7d0866fcfe259 2 2 1'])
  let expected = ['0000000000000000000000000000000000000000 1 1 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: Two matching string in lines [would be returned from IngestGitAnnotate]):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 2 2 1'])
  let expected = ['0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 2 2 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: Two matching string in lines with not-matched in between):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 1 1 1', '19d605f410c83235ae7E757445e7d0866fcfe259 2 2 2', '19d605f410c83235ae7E757445e7d0866fcfe259 3 3', '0000000000000000000000000000000000000000 4 4 1'])
  let expected = ['0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 4 4 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: Two matching string in lines with not-matched in between, double digit lines):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 11 11 1', '19d605f410c83235ae7E757445e7d0866fcfe259 12 12 2', '19d605f410c83235ae7E757445e7d0866fcfe259 13 13', '0000000000000000000000000000000000000000 14 14 1'])
  let expected = ['0000000000000000000000000000000000000000 11 11 1', '0000000000000000000000000000000000000000 14 14 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: Two matching string in lines with not-matched in between, triple digit lines):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 111 111 1', '19d605f410c83235ae7E757445e7d0866fcfe259 112 112 2', '19d605f410c83235ae7E757445e7d0866fcfe259 113 113', '0000000000000000000000000000000000000000 114 114 1'])
  let expected = ['0000000000000000000000000000000000000000 111 111 1', '0000000000000000000000000000000000000000 114 114 1'] 
  AssertEqual expected, input

Execute(CollectUncommittedLines: Two matching string in lines with not-matched in between, quadruple digit lines):
  let input = CollectUncommittedLines(['0000000000000000000000000000000000000000 1111 1111 1', '19d605f410c83235ae7E757445e7d0866fcfe259 1112 1112 2', '19d605f410c83235ae7E757445e7d0866fcfe259 1113 1113', '0000000000000000000000000000000000000000 1114 1114 1'])
  let expected = ['0000000000000000000000000000000000000000 1111 1111 1', '0000000000000000000000000000000000000000 1114 1114 1'] 
  AssertEqual expected, input

Execute(CleanLines returns a list):
  let input = CleanLines([])
  let expected = []
  AssertEqual expected, input

Execute(CleanLines throws an error with a string argument type):
  AssertThrows CleanLines("string")

Execute(CleanLines throws an error with a number argument type):
  AssertThrows CleanLines(1)

Execute(CleanLines throws an error with a float argument type):
  AssertThrows CleanLines(2.424241)

Execute(CleanLines throws an error with a dict argument type):
  let diction = #{a: 'aa', b: 'bb'}
  AssertThrows CleanLines(diction)

  "TODO funcref

Execute(CleanLines throws an error with a boolean argument type):
  AssertThrows CleanLines(v:true)

Execute(CleanLines throws an error with a false boolean argument type):
  AssertThrows CleanLines(v:false)

Execute(CleanLines throws an error with a null argument type):
  AssertThrows CleanLines(v:null)

Execute(CleanLines throws an error with a numbers in list):
  AssertThrows CleanLines([1,2])

Execute(CleanLines throws an error with floats in list):
  AssertThrows CleanLines([1.86523, 2.7523])

Execute(CleanLines throws an error with two strings in list):
  AssertThrows CleanLines(["StringX", "StringY"])

Execute(CleanLines throws error if line numbers are duplicated):
  AssertThrows CleanLines(['0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1', '0000000000000000000000000000000000000000 1 1 1'])

Execute(CleanLines throws error if line numbers are out of order):
  AssertThrows CleanLines(['0000000000000000000000000000000000000000 2 2', '0000000000000000000000000000000000000000 1 1 2'])

Execute(CleanLines returns the same length list as input: length):
  let input = CleanLines(['0000000000000000000000000000000000000000 1 1 13', '0000000000000000000000000000000000000000 2 2', '0000000000000000000000000000000000000000 3 3', '0000000000000000000000000000000000000000 4 4', '0000000000000000000000000000000000000000 5 5', '0000000000000000000000000000000000000000 6 6', '0000000000000000000000000000000000000000 7 7', '0000000000000000000000000000000000000000 8 8', '0000000000000000000000000000000000000000 9 9', '0000000000000000000000000000000000000000 10 10', '0000000000000000000000000000000000000000 11 11', '0000000000000000000000000000000000000000 12 12', '0000000000000000000000000000000000000000 13 13'])
  let expected = 13 
  AssertEqual expected, len(input) 

Execute(CleanLines returns the same length list as input: list):
  let input = CleanLines(['0000000000000000000000000000000000000000 1 1 13', '0000000000000000000000000000000000000000 2 2', '0000000000000000000000000000000000000000 3 3', '0000000000000000000000000000000000000000 4 4', '0000000000000000000000000000000000000000 5 5', '0000000000000000000000000000000000000000 6 6', '0000000000000000000000000000000000000000 7 7', '0000000000000000000000000000000000000000 8 8', '0000000000000000000000000000000000000000 9 9', '0000000000000000000000000000000000000000 10 10', '0000000000000000000000000000000000000000 11 11', '0000000000000000000000000000000000000000 12 12', '0000000000000000000000000000000000000000 13 13'])
  AssertEqual v:t_list, type(input)

Execute(CleanLines: Throws error if no matching strings in list, if hash off by one digit substitution [invalid input]):
  AssertThrows CleanLines(['0000000000100000000000000000000000000000 1 1 1'])
  
Execute(CleanLines: Throws error if no matching strings in list, noise [invalid input]):
  AssertThrows CleanLines(['&%@EbV@U^!R(&lhB!O*61UYTv79nF!&^T1', 'JtHTExUt6d$756G{]KNMN&^r%s4sp8i7G*I&654d&%$sFV'])

Execute(CleanLines: Simple match):
  let input = CleanLines(['0000000000000000000000000000000000000000 1 1 1'])
  let expected = [1] 
  AssertEqual expected, input

Execute(CleanLines: Two matching strings in uncommittedlines):
  let input = CleanLines(['0000000000000000000000000000000000000000 1 1 2', '0000000000000000000000000000000000000000 2 2'])
  let expected = [1, 2] 
  AssertEqual expected, input

Execute(CleanLines: Throws error if two matching strings in lines, with not-matched in between, quadruple digit lines [invalid input]):
  AssertThrows CleanLines(['0000000000000000000000000000000000000000 1111 1111 1', '19d605f410c83235ae7E757445e7d0866fcfe259 1112 1112 2', '19d605f410c83235ae7E757445e7d0866fcfe259 1113 1113', '0000000000000000000000000000000000000000 1114 1114 1'])

Execute(CleanLines: Many lines up to 5 digits):
  let input = CleanLines(['0000000000000000000000000000000000000000 1 1 2', '0000000000000000000000000000000000000000 2 2', '0000000000000000000000000000000000000000 23 23 3', '0000000000000000000000000000000000000000 24 24', '0000000000000000000000000000000000000000 25 25', '0000000000000000000000000000000000000000 255 255 2', '0000000000000000000000000000000000000000 256 256', '0000000000000000000000000000000000000000 2701 2702 1', '0000000000000000000000000000000000000000 29752 29724 1'])
  let expected = [1, 2, 23, 24, 25, 255, 256, 2702, 29724] 
  AssertEqual expected, input

Execute(CleanLines: Many lines up to 5 digits, one out of order [invalid input]):
  "let input = 
  AssertThrows CleanLines(['0000000000000000000000000000000000000000 1 1 2', '0000000000000000000000000000000000000000 23 23 3', '0000000000000000000000000000000000000000 2 2', '0000000000000000000000000000000000000000 24 24', '0000000000000000000000000000000000000000 25 25', '0000000000000000000000000000000000000000 255 255 2', '0000000000000000000000000000000000000000 256 256', '0000000000000000000000000000000000000000 2701 2702 1', '0000000000000000000000000000000000000000 29752 29724 1'])
  "let expected = error  
  "AssertEqual expected, input

" investigate negative numbers in createranges 

"Execute(CleanedLines returns a list):
"  let input = CleanedLines([])
"  let expected = []
"  AssertEqual expected, input

"  testing could be expanded into a collection of possible states for file changes

"  TODO : tests for external files, starting with empty file 
"  (unit integration)
"  then:
"  full file, no modifications
"  completely deleted file
"  various extensions
"  .. non C++ file with C++ extension
